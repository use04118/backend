# utils/excel_utils.py

import io
from openpyxl import Workbook
from openpyxl.utils import get_column_letter
from django.http import HttpResponse

def generate_excel(headers, data, filename="report.xlsx"):
    """
    Generates an Excel file from the provided headers and data.
    """
    # Create an Excel workbook and sheet
    wb = Workbook()
    ws = wb.active
    ws.title = "Report"

    # Add headers to the sheet
    for col_num, header in enumerate(headers, 1):
        col_letter = get_column_letter(col_num)
        ws[f"{col_letter}1"] = header

    # Add data to the sheet
    for row_num, row in enumerate(data, 2):
        for col_num, value in enumerate(row, 1):
            col_letter = get_column_letter(col_num)
            ws[f"{col_letter}{row_num}"] = value

    # Prepare the response for Excel download
    response = HttpResponse(
        content_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    )
    response["Content-Disposition"] = f"attachment; filename={filename}"

    # Save the workbook into the response
    wb.save(response)

    return response





# utils/decorators.py

from functools import wraps
from django.http import JsonResponse
from .excel_utils import generate_excel

def export_excel_view(view_func):
    """
    Decorator that checks if 'export_excel' is present in the query parameters.
    If so, generates an Excel file for the response.
    """
    @wraps(view_func)
    def wrapper(request, *args, **kwargs):
        # Check if export_excel query param is present
        if request.GET.get('export_excel') == 'true':
            # Call the view function to get the data
            response_data = view_func(request, *args, **kwargs)

            # Ensure the response is a JsonResponse and has data
            if isinstance(response_data, JsonResponse):
                # Extract headers and data from the response
                if 'transactions' in response_data.data:
                    headers = list(response_data.data[0].keys()) if response_data.data else []
                    data = [list(item.values()) for item in response_data.data]

                    # Generate the Excel file and return
                    return generate_excel(headers, data, filename="report.xlsx")
            # If the response is not in expected format
            return JsonResponse({"error": "Invalid data format for Excel export"}, status=400)

        # If not exporting, return the original response
        return view_func(request, *args, **kwargs)

    return wrapper


from .utils.decorators import export_excel_view  # Import the decorator
@export_excel_view  # Apply the decorator here

?export_excel=true

class Invoice(models.Model):
    STATUS_CHOICES = [
        ('Unpaid', 'Unpaid'),
        ('Partially Paid', 'Partially Paid'),
        ('Paid', 'Paid')
    ]
    
    PAYMENT_METHOD_CHOICES = (
        ('Cash', "Cash"),
        ('UPI', "UPI"),
        ('Card', "Card"),
        ('Netbanking', "Netbanking"),
        ('Bank Transfer', "Bank Transfer"),
        ('Cheque', "Cheque"),
    )
    
    TCS_ON_CHOICES = (
    ('taxable', 'taxable'),
    ('total', 'total'),
)

    business = models.ForeignKey(Business, on_delete=models.CASCADE, blank=True , null=True, related_name='invoice')
    invoice_no = models.CharField(max_length=50)
    date = models.DateField(auto_now_add=False)
    party = models.ForeignKey(Party, on_delete=models.CASCADE, related_name='invoice')
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='Unpaid')
    payment_term = models.PositiveIntegerField(help_text="Number of days for the payment term", blank=True, null=True,default=30)
    due_date = models.DateField(blank=True, null=True)
    is_fully_paid = models.BooleanField(default=False, help_text="Mark as fully paid")
    amount_received = models.DecimalField(max_digits=10, decimal_places=2, default=0.0, help_text="Amount received")
    balance_amount = models.DecimalField(max_digits=10, decimal_places=2, default=0.0, help_text="Balance Amount")
    total_amount = models.DecimalField(max_digits=10, decimal_places=2, default=0.0, help_text="Total Amount")
    taxable_amount = models.DecimalField(max_digits=10, decimal_places=2, default=0.0, help_text="Taxable Amount")
    payment_method = models.CharField(max_length=20, choices=PAYMENT_METHOD_CHOICES,  default='Cash', blank=True, null=True)
    discount = models.DecimalField(max_digits=5, decimal_places=2, default=0,blank=True , null=True, help_text="Discount in percentage.")
    notes = models.TextField(blank=True,null=True)
    signature = models.ImageField(upload_to='static/images/', null=True, blank=True)
    bank_account = models.ForeignKey('cash_and_bank.BankAccount', on_delete=models.SET_NULL, null=True, blank=True, related_name='invoices')
    
    apply_tcs = models.BooleanField(default=False)
    tcs = models.ForeignKey('Tcs',on_delete=models.SET_NULL, blank=True , null=True, related_name='invoice_tcs')
    tcs_on = models.CharField(max_length=20, choices=TCS_ON_CHOICES,default='total',help_text="Apply TCS on either taxable or total amount")
    tcs_amount = models.DecimalField(max_digits=10, decimal_places=2, default=0.0, help_text="TCS Amount")

    def save(self, *args, **kwargs):
        # Automatically calculate due_date
            
        if self.date and self.payment_term:
            self.due_date = self.date + timedelta(days=self.payment_term)

        # Save the invoice first to get the primary key (for editing)
        is_new = not self.pk

        if is_new:
            # For new invoice, do the first save
            print("new save --")
            super().save(*args, **kwargs)

        self.total_amount = self.get_total_amount()
        self.taxable_amount = self.get_taxable_amount()
        self.balance_amount = self.get_balance_amount()
        self.tcs_amount = self.get_tcs_amount()
        # Now that it has a primary key, you can safely calculate total amount
        if not is_new:
            print("old invoice -- 1")
            self.reverse_previous_balance_impact()

        # Now that the invoice has been saved, proceed with the balance update
        if self.is_fully_paid:
            self.handle_fully_paid()
        elif self.amount_received > 0:
            self.handle_partially_paid()
        else:
            self.handle_unpaid()

        # Update the status of the invoice (Paid/Unpaid/Partially Paid)
        self.update_status()

        # Save the updated fields (no double save)
        super().save(update_fields=['party', 'status', 'amount_received', 'total_amount', 'balance_amount',
    'is_fully_paid', 'due_date', 'notes', 'discount', 'payment_method',
    'payment_term', 'business', 'tcs_amount','tcs','apply_tcs', 'taxable_amount','bank_account'])

    def handle_fully_paid(self):
        # âœ… Scenario 1 & Scenario 4: Fully Paid (at creation or after edit)
        # No balance changes to the party
        self.status = 'Paid'
        self.amount_received = self.get_total_amount()
        print("paid success")

    def handle_partially_paid(self):
        # âœ… Scenario 3 & Scenario 5: Partially Paid
        total_amount = self.get_total_amount()
        remaining_amount = total_amount - self.amount_received
        print(remaining_amount , total_amount , self.amount_received)

        # Step 1: Deduct from To Pay
        if self.party.balance_type == 'To Pay' and self.party.closing_balance > 0:
            if remaining_amount >= self.party.closing_balance:
                remaining_amount -= self.party.closing_balance
                self.party.closing_balance = 0
                self.party.balance_type = 'To Collect'
            else:
                self.party.closing_balance -= remaining_amount
                remaining_amount = 0

        # Step 2: Add remaining amount (if any) to To Collect
        if remaining_amount > 0:
            if self.party.balance_type == 'To Pay' and self.party.closing_balance == 0:
                self.party.balance_type = 'To Collect'
            self.party.closing_balance += remaining_amount

        self.party.save()
        self.status = 'Partially Paid'
        print("Partially paid success")

    def handle_unpaid(self):
        # âœ… Scenario 2 & Scenario 6: Unpaid
        total_amount = self.get_total_amount()
        remaining_amount = total_amount

        # Step 1: Deduct from To Pay
        if self.party.balance_type == 'To Pay' and self.party.closing_balance > 0:
            if remaining_amount >= self.party.closing_balance:
                remaining_amount -= self.party.closing_balance
                self.party.closing_balance = 0
                self.party.balance_type = 'To Collect'
            else:
                self.party.closing_balance -= remaining_amount
                remaining_amount = 0

        # Step 2: Add remaining amount (if any) to To Collect
        if remaining_amount > 0:
            if self.party.balance_type == 'To Pay' and self.party.closing_balance == 0:
                self.party.balance_type = 'To Collect'
            self.party.closing_balance += remaining_amount

        self.party.save()
        self.status = 'Unpaid'
        print("Unpaid success")

    def reverse_previous_balance_impact(self):
        # âœ… Reverse any previous balance impact based on the old status
        try:
            old_invoice = Invoice.objects.get(pk=self.pk)
        except Invoice.DoesNotExist:
            # Handle the case where the old invoice doesn't exist (shouldn't happen in a valid state)
            print("Old invoice does not exist.")
            return
        

        # Case 1: Fully Paid - No impact to reverse
        if old_invoice.status == 'Paid':
            return

        # Case 2: Unpaid or Partially Paid
        if old_invoice.status in ['Unpaid', 'Partially Paid']:
            total_amount = old_invoice.get_total_amount()
            received_amount = old_invoice.amount_received  # Should be set correctly during the save
            balance_amount = total_amount - received_amount  # Should be set correctly during the save

            print(f"Total Amount: {total_amount}")
            print(f"Received Amount: {received_amount}")
            print(f"Balance Amount: {balance_amount}")
            print(f"Old invoice status: {old_invoice.status}")

            # Reverse impact based on the old balance type
            if old_invoice.status == 'Unpaid':
                self.reverse_unpaid_balance(total_amount)
            elif old_invoice.status == 'Partially Paid':
                self.reverse_partially_paid_balance(balance_amount)
            
        old_party = old_invoice.party
        if old_party != self.party:
            print("Party changed. Reversing old party balance impact.")
            self.transfer_balance_to_new_party(old_party,balance_amount)

    def reverse_unpaid_balance(self, total_amount):
        # âœ… Reverse the unpaid logic impact
        if self.party.balance_type == 'To Collect':
            self.party.closing_balance -= total_amount
            if self.party.closing_balance < 0:
                self.party.balance_type = 'To Pay'
                self.party.closing_balance = abs(self.party.closing_balance)
        elif self.party.balance_type == 'To Pay':
            self.party.closing_balance += total_amount
        self.party.save()

    def reverse_partially_paid_balance(self, received_amount):
        # Reverse the partially paid logic impact based on previous payments
        if self.party.balance_type == 'To Collect':
            self.party.closing_balance -= received_amount
            if self.party.closing_balance < 0:
                self.party.balance_type = 'To Pay'
                self.party.closing_balance = abs(self.party.closing_balance)
        elif self.party.balance_type == 'To Pay':
            self.party.closing_balance += received_amount
        self.party.save()

    def update_status(self):
        total_amount = self.get_total_amount()
        if self.is_fully_paid or self.amount_received >= total_amount:
            self.status = 'Paid'
        elif self.amount_received > 0:
            self.status = 'Partially Paid'
        else:
            self.status = 'Unpaid'
        print(self.status)

    def get_tcs_amount(self):
        if self.apply_tcs and self.tcs and self.business and self.business.tcs:
            rate = self.tcs.rate or Decimal('0.00')

            if self.tcs_on == 'total':
                base_amount = self.get_total_amount(without_tcs=True)
            else:
                base_amount = self.get_taxable_amount()

            return (base_amount * rate / Decimal('100.00')).quantize(Decimal("0.00"), rounding=ROUND_HALF_UP)

        return Decimal("0.00")


    def get_total_amount(self, without_tcs=False):
        total_amount = sum(Decimal(str(item.get_amount())) for item in self.invoice_items.all())

        discount = Decimal(self.discount or 0)
        if discount > 0:
            total_amount -= (total_amount * (discount / Decimal("100")))

        # Ensure total_amount is Decimal before quantizing
        total_amount = Decimal(total_amount)

        if not without_tcs and self.apply_tcs and self.tcs and self.business and self.business.tcs:
            rate = Decimal(str(self.tcs.rate or 0))
            tcs_base = self.get_taxable_amount() if self.tcs_on == 'taxable' else total_amount
            self.tcs_amount = (tcs_base * rate / Decimal("100")).quantize(Decimal("0.00"), rounding=ROUND_HALF_UP)
            total_amount += self.tcs_amount
        else:
            self.tcs_amount = Decimal("0.00")

        return total_amount.quantize(Decimal("0.00"), rounding=ROUND_HALF_UP)
    
    def get_balance_amount(self):
        total_amount = self.get_total_amount()
        amount_received = Decimal(self.amount_received or 0)
        return total_amount - amount_received

    def get_taxable_amount(self):
        # Convert each price item to Decimal before summing
        total_amount = sum(Decimal(item.get_price_item()) for item in self.invoice_items.all())
        
        # Use 0 if discount is None
        discount = self.discount if self.discount is not None else 0
        
        if discount >= 0:
            discount_amount = total_amount * Decimal(discount / 100)  # Discount is a percentage
            total_amount -= discount_amount  # Subtract discount from total amount
        
        return total_amount
    
    def transfer_balance_to_new_party(self, old_party,balance_amount):
        # total_amount = self.get_total_amount()  # Get total amount from the invoice
        new_party = self.party  # The new party to receive the amount
        print(f"Old Party Balance before: {old_party.closing_balance}")
        print(f"New Party Balance before: {new_party.closing_balance}")

        # # Step 1: Deduct the balance from the old party (only once)
        if old_party.balance_type == 'To Collect':
            old_party.closing_balance -= balance_amount
            if old_party.closing_balance < 0:
                old_party.balance_type = 'To Pay'
                old_party.closing_balance = abs(old_party.closing_balance)
        elif old_party.balance_type == 'To Pay':
            old_party.closing_balance += balance_amount
        
        # # Step 2: Add the balance from the old party (only once)
        if new_party.balance_type == 'To Collect':
            new_party.closing_balance += balance_amount
            if new_party.closing_balance < 0:
                new_party.balance_type = 'To Pay'
                new_party.closing_balance = abs(new_party.closing_balance)
        elif new_party.balance_type == 'To Pay':
            new_party.closing_balance -= balance_amount


        old_party.save()  # Save the old party after the deduction
        print(f"Old party balance reduced by: {balance_amount}")

        # # Save the new party once to avoid duplication
        new_party.save()  # Save the new party after the correct balance update

        print(f"Old Party Balance after: {old_party.closing_balance}")
        print(f"New Party Balance after: {new_party.closing_balance}")

    def delete(self, *args, **kwargs):
        # Handle necessary clean up before deleting the invoice or invoice item
        self.reverse_previous_balance_impact()  # Example: Reverse balance impact for the party
        super().delete(*args, **kwargs)

    def make_payment(self, total_payment_amount, bank_account=None):
        self.balance_amount = self.get_balance_amount()  # Update balance amount

        # If the invoice balance is greater than the payment amount
        if self.balance_amount >= total_payment_amount:
            self.amount_received += total_payment_amount
            if self.balance_amount == self.amount_received:
                self.balance_amount = 0
            total_payment_amount = 0  # All the payment has been consumed
        else:
            # If the invoice balance is less than the payment amount, deduct the entire balance
            total_payment_amount -= self.balance_amount
            self.amount_received += self.balance_amount
            self.balance_amount = 0  # Invoice is fully paid

        # Update bank account if provided
        if bank_account:
            self.bank_account = bank_account
            # Set payment method based on bank account type
            if bank_account.account_type == 'Cash':
                self.payment_method = 'Cash'
            else:
                self.payment_method = 'Bank Transfer'

        self.is_fully_paid = self.balance_amount == 0
        if self.is_fully_paid:
            print("Fully paid Payment in progress")
            total_amount = self.get_total_amount()
            received_amount = self.amount_received  # Should be set correctly during the save
            balance_amount = self.balance_amount  # Should be set correctly during the save

            print(f"Total Amount: {total_amount}")
            print(f"Received Amount: {received_amount}")
            print(f"Balance Amount: {balance_amount}")
            print(f"Old invoice status: {self.status}")

            # Reverse impact based on the old balance type
            if self.status == 'Unpaid':
                self.reverse_unpaid_balance(total_amount)
            elif self.status == 'Partially Paid':
                self.reverse_partially_paid_balance(balance_amount)
            
        self.update_status()  # Update the status (Paid/Partially Paid/Unpaid)

        # Save the updated invoice
        self.save(update_fields=['amount_received', 'balance_amount', 'is_fully_paid', 'status', 'bank_account', 'payment_method'])

        return total_payment_amount  # Return the remaining amount that can be used for other invoices

    class Meta:
        unique_together = ('business', 'invoice_no')  # or UniqueConstraint
        ordering = ['invoice_no']
        
    def __str__(self):
        return f"Invoice {self.invoice_no} - {self.party}"   

    @classmethod
    def get_next_invoice_number(cls, business):
        """Generate the next invoice number for a business."""
        # Get the latest invoice for this specific business
        latest_invoice = cls.objects.filter(business=business).order_by('-id').first()
        
        if latest_invoice:
            # Extract the number part and increment
            last_number = int(latest_invoice.invoice_no)
            next_invoice_no = last_number + 1
        else:
            # First invoice for this business
            next_invoice_no = 1
            
        return next_invoice_no


class InvoiceItem(models.Model):
    invoice = models.ForeignKey(Invoice, related_name='invoice_items', on_delete=models.CASCADE)
    item = models.ForeignKey(Item, null=True, blank=True, on_delete=models.CASCADE)  # For products
    service = models.ForeignKey(Service, null=True, blank=True, on_delete=models.CASCADE)  # For services
    quantity = models.DecimalField(max_digits=10, decimal_places=2)
    unit_price = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)  # Unit price for both products and services
    amount = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)  # Total amount for the item or service
    discount = models.DecimalField(max_digits=5, decimal_places=2, default=0, help_text="Discount in percentage.")
    price_item = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)  # Price of item/service before tax
    gstTaxRate = models.ForeignKey(GSTTaxRate, on_delete=models.SET_NULL, null=True)
    
    
    def clean(self):
        """Ensure either item or service is selected, not both."""
        if not self.item and not self.service:
            raise ValidationError("Either 'item' or 'service' must be provided.")
        if self.item and self.service:
            raise ValidationError("You can only select either 'item' or 'service', not both.")
    
    def get_tax_rate_amount(self):
        """Calculate GST tax amount."""
        if self.gstTaxRate:
            tax_rate = self.gstTaxRate.rate / 100 if self.gstTaxRate else 0
            return (self.get_price_item() * tax_rate)
        return Decimal(0)

    def get_cess_rate_amount(self):
        """Calculate cess amount."""
        if self.gstTaxRate:
            cess_rate = self.gstTaxRate.cess_rate / 100 if self.gstTaxRate else 0
            return (self.get_price_item() * cess_rate)
        return Decimal(0)
    
    def get_cgst_amount(self):
        """Calculate GST tax amount."""
        if self.gstTaxRate:
            tax_rate = self.gstTaxRate.rate / 200 if self.gstTaxRate else 0
            return (self.get_price_item() * tax_rate)
        return Decimal(0)

    def get_sgst_amount(self):
        """Calculate cess amount."""
        if self.gstTaxRate:
            tax_rate = self.gstTaxRate.rate / 200 if self.gstTaxRate else 0
            return (self.get_price_item() * tax_rate)
        return Decimal(0)
    
    def get_igst_amount(self):
        """Calculate IGST tax amount."""
        if self.gstTaxRate:
            igst_rate = self.gstTaxRate.rate / 100 if self.gstTaxRate else 0  # IGST uses full rate
            return (self.get_price_item() * igst_rate)
        return Decimal(0)
        
    def get_cgst(self):
        if self.gstTaxRate:
            return (self.gstTaxRate.rate/2)
        return Decimal(0)
    
    def get_sgst(self):
        if self.gstTaxRate:
            return (self.gstTaxRate.rate/2)
        return Decimal(0)
    
    def get_salesPrice_with_tax(self):
        """Returns the tax-inclusive sales price if stored without tax."""
        if self.item:
            if self.item.salesPriceType == "With Tax":
                price_with_tax = self.calculate_price(self.item.salesPrice, "With Tax")
                return (price_with_tax)
            return (self.item.salesPrice)  # Already tax-exclusive
        elif self.service:
            if self.service.salesPriceType == "With Tax":
                price_with_tax = self.calculate_price(self.service.salesPrice, "With Tax")
                return (price_with_tax)
            return (self.service.salesPrice)  # Service price * quantity
        return 0.0
    
    def get_salesPrice_without_tax(self):
        """Returns the tax-inclusive sales price if stored without tax."""
        if self.item:
            if self.item.salesPriceType == "Without Tax":
                price_without_tax = self.calculate_price(self.item.salesPrice, "Without Tax")
                return (price_without_tax)
            return (self.item.salesPrice)  # Already tax-exclusive
        elif self.service:
            if self.service.salesPriceType == "Without Tax":
                price_without_tax = self.calculate_price(self.service.salesPrice, "Without Tax")
                return (price_without_tax)
            return (self.service.salesPrice)  # Service price * quantity
        return 0.0
    
    def get_purchasePrice_with_tax(self):
        """Returns the tax-inclusive sales price if stored without tax."""
        if self.item:
            if self.item.purchasePriceType == "With Tax":
                price_without_tax = self.calculate_price(self.item.purchasePrice, "With Tax")
                return (price_without_tax)
            return (self.item.purchasePrice)  # Already tax-exclusive
        return 0.0
    
    def get_purchasePrice_without_tax(self):
        """Returns the tax-inclusive sales price if stored without tax."""
        if self.item:
            if self.item.purchasePriceType == "Without Tax":
                price_without_tax = self.calculate_price(self.item.purchasePrice, "Without Tax")
                return (price_without_tax)
            return (self.item.purchasePrice)  # Already tax-exclusive
        return 0.0
    
    def get_price_type(self):
        if self.item:
            if self.item.salesPriceType == "With Tax":
                return (self.item.salesPriceType)
            return (self.item.salesPriceType)  # Already tax-exclusive
        elif self.service:
            if self.service.salesPriceType == "With Tax":
                return (self.service.salesPriceType)
            return (self.service.salesPriceType)  # Service price * quantity
    
    def get_type(self):
        if self.item:
            if self.item.itemType == "Product":
                return 'item'
        elif self.service:
            if self.service.serviceType == "Service":
                return 'service'
    
    def calculate_price(self, price, price_type):
        """Calculates tax-inclusive or tax-exclusive price based on GST and Cess rate."""
        tax_rate = self.gstTaxRate.rate / 100 if self.gstTaxRate else 0
        cess_rate = self.gstTaxRate.cess_rate / 100 if self.gstTaxRate else 0
        
        # Combined GST + Cess rate
        total_rate = tax_rate + cess_rate
        
        if price_type == "With Tax":
            # Extract base price from tax-inclusive price
            return (price / (1 + total_rate)) if total_rate > 0 else price
        else:
            # Add GST + Cess to the base price
            return (price * (1 + total_rate))
        
    def get_amount(self):
        """Calculates the total amount for the item or service, applying discounts if any."""
        if self.item:
            if self.item.salesPriceType == "Without Tax":
                price_with_tax = self.calculate_price(self.item.salesPrice, "Without Tax")
                total_amount = round(price_with_tax * self.quantity, 2)
            else:
                total_amount = round(self.item.salesPrice * self.quantity, 2)  # Already tax-inclusive
             # Apply the discount to the total amount (if any)
            if self.discount > 0:
                discount_amount = total_amount * (self.discount / 100)  # Discount is a percentage
                total_amount -= discount_amount  # Subtract discount from total amount
            return round(total_amount, 2)
        elif self.service:
            if self.service.salesPriceType == "Without Tax":
                price_with_tax = self.calculate_price(self.service.salesPrice, "Without Tax")
                total_amount = round(price_with_tax * self.quantity, 2)
            else:
            # For services, calculate the amount based on the service price and apply discount
                total_amount = round(self.service.salesPrice * self.quantity, 2)
            # Apply the discount to the total amount (if any)
            if self.discount > 0:
                discount_amount = total_amount * (self.discount / 100)  # Discount is a percentage
                total_amount -= discount_amount  # Subtract discount from total amount
            return round(total_amount, 2)       
        return 0.0  # If no item or service, return 0

    def get_price_item(self):
        """Returns the price of the item or service (excluding tax), applying discounts if any."""
        
        total_price = 0.0
        
        if self.item:
            # Handle item price calculation based on sales type
            if self.item.salesPriceType == "With Tax":
                price_without_tax = self.calculate_price(self.item.salesPrice, "With Tax")
                total_price = price_without_tax * self.quantity
            else:
                total_price = self.item.salesPrice * self.quantity  # Already tax-exclusive
            
            # Apply discount if any
            if hasattr(self, 'discount') and self.discount > 0:
                discount_amount = total_price * (self.discount / 100)
                total_price -= discount_amount
        
        elif self.service:
            # Handle service price calculation based on sales type
            if self.service.salesPriceType == "With Tax":
                price_without_tax = self.calculate_price(self.service.salesPrice, "With Tax")
                total_price = price_without_tax * self.quantity
            else:
                total_price = self.service.salesPrice * self.quantity
            
            # Apply discount if any
            if hasattr(self, 'discount') and self.discount > 0:
                discount_amount = total_price * (self.discount / 100)
                total_price -= discount_amount
        
        # Return the final price, rounded to two decimal places
        return round(total_price, 2)

    def get_available_stock(self):
        """Returns the remaining stock for products. For services, stock is not managed."""
        if self.item:
            # Create a unique cache key for each item
            cache_key = f'item_{self.item.id}_stock_{self.quantity}'  # Include quantity in the key to handle dynamic changes
            available_stock = cache.get(cache_key)  # Check if the result is cached
            if available_stock is None:  # Cache miss - calculate available stock
                if self.item.closingStock >= self.quantity:
                    available_stock = self.item.closingStock - self.quantity
                else:
                    available_stock = 0  # Out-of-stock for products
                # Store the result in cache for 15 minutes (adjustable)
                cache.set(cache_key, available_stock)
            if available_stock <= 0:
                raise ValidationError(f"Not enough stock for {self.item.itemName}. Available stock: {self.item.closingStock}")
            return available_stock
        return None  # Services don't have stock management

    def save(self, *args, **kwargs):
        """Override save method to calculate amount and unit price for both items and services."""
        self.full_clean()  # Ensure validation
        if self.item:
            self.unit_price = self.item.salesPrice  # For products
            self.price_item = self.item.salesPrice  # Price of item before tax
            # Check if sufficient stock is available and update
            available_stock = self.get_available_stock()
            if available_stock >= 0:
                self.item.closingStock = available_stock
                self.item.save()  # Persist the updated stock to the database
                # Invalidate the cache for this item
                cache_key = f'item_{self.item.id}_stock'
                cache.delete(cache_key)  # Clear the old cached value
                # Optionally, you could also update the cache with the new stock value
                cache.set(cache_key, self.item.closingStock)
            else:
                raise ValidationError("Not enough stock available.")
            
        elif self.service:
            self.unit_price = self.service.salesPrice  # For services
            self.price_item = self.service.salesPrice  # Service price before tax
        self.amount = self.get_amount()  # Calculate the total amount (based on item or service)

        super().save(*args, **kwargs)


    def __str__(self):
        if self.item:
            return f"{self.item.itemName} ({self.quantity} * {self.unit_price})"
        elif self.service:
            return f"{self.service.serviceName} ({self.quantity} * {self.unit_price})"
        return "Unknown Item or Service"


class InvoiceItemSerializer(serializers.ModelSerializer):
    item_name = serializers.CharField(source='item.itemName', read_only=True)
    service_name = serializers.CharField(source='service.serviceName', read_only=True)
    available_stock = serializers.DecimalField(source='get_available_stock', read_only=True, max_digits=10, decimal_places=2)
    price_item = serializers.DecimalField(source='get_price_item', read_only=True, max_digits=10, decimal_places=2)
    amount = serializers.DecimalField(source='get_amount', read_only=True, max_digits=10, decimal_places=2)
    tax_rate = serializers.DecimalField(source='gstTaxRate.rate', read_only=True, max_digits=5, decimal_places=2)
    tax_rate_amount = serializers.DecimalField(source='get_tax_rate_amount', read_only=True, max_digits=10, decimal_places=2)
    cess_rate = serializers.DecimalField(source='gstTaxRate.cess_rate', read_only=True, max_digits=5, decimal_places=2)
    cess_rate_amount = serializers.DecimalField(source='get_cess_rate_amount', read_only=True, max_digits=10, decimal_places=2)
    cgst = serializers.DecimalField(source='get_cgst', read_only=True, max_digits=5, decimal_places=2)
    cgst_amount = serializers.DecimalField(source='get_cgst_amount', read_only=True, max_digits=10, decimal_places=2)
    igst = serializers.DecimalField(source='gstTaxRate.rate', read_only=True, max_digits=5, decimal_places=2)
    igst_amount = serializers.DecimalField(source='get_igst_amount', read_only=True, max_digits=10, decimal_places=2)
    sgst = serializers.DecimalField(source='get_sgst', read_only=True, max_digits=5, decimal_places=2)
    sgst_amount = serializers.DecimalField(source='get_sgst_amount', read_only=True, max_digits=10, decimal_places=2)
    hsnCode = serializers.CharField(source='item.hsnCode', read_only=True)
    sacCode = serializers.CharField(source='service.sacCode', read_only=True)
    salesPrice_with_tax = serializers.DecimalField(source='get_salesPrice_without_tax', read_only=True, max_digits=5, decimal_places=2)
    purchasePrice_with_tax = serializers.DecimalField(source='get_purchasePrice_without_tax', read_only=True, max_digits=5, decimal_places=2)
    salesPrice_without_tax = serializers.DecimalField(source='get_salesPrice_with_tax', read_only=True, max_digits=5, decimal_places=2)
    purchasePrice_without_tax = serializers.DecimalField(source='get_purchasePrice_with_tax', read_only=True, max_digits=5, decimal_places=2)
    salesPriceType = serializers.CharField(source='get_price_type', read_only=True)
    type = serializers.CharField(source='get_type', read_only=True)
    
    class Meta:
        model = InvoiceItem
        fields = [
            'id', 'invoice', 'item', 'item_name', 'service', 'service_name', 
            'quantity', 'unit_price', 'amount', 'price_item', 'available_stock', 'gstTaxRate', 'discount',
            'tax_rate', 'tax_rate_amount', 'cess_rate', 'cess_rate_amount' , 'igst' , 'igst_amount' , 'cgst' , 'cgst_amount' , 'sgst', 'sgst_amount', 'hsnCode' , 'sacCode',
            'salesPrice_with_tax', 'purchasePrice_with_tax', 'salesPrice_without_tax', 'purchasePrice_without_tax', 'salesPriceType','type'
        ]
        extra_kwargs = {
            'invoice': {'required': False}  # ðŸ‘ˆ This is the fix
        }

    def validate(self, data):
        """Ensure either item or service is provided, not both."""
        item = data.get('item')
        service = data.get('service')

        if not item and not service:
            raise serializers.ValidationError("Either 'item' or 'service' must be provided.")
        if item and service:
            raise serializers.ValidationError("You can only select either 'item' or 'service', not both.")
        if 'quantity' in data and data['quantity'] <= 0:
            raise serializers.ValidationError("Quantity must be a positive number.")

        # Ensure stock availability for items
        if item:
            if item.closingStock < data['quantity']:
                raise serializers.ValidationError(f"Not enough stock for {item.itemName}. Available: {item.closingStock}")
        return data
    
    def create(self, validated_data):
        """Create InvoiceItem and deduct stock."""
        item = validated_data.get('item')
        invoice_item = InvoiceItem.objects.create(**validated_data)

        # âœ… Deduct stock if it's an item (not service)
        if item:
            item.closingStock -= validated_data['quantity']
            item.save()

        return invoice_item
    
    def update(self, instance, validated_data):
        """Update InvoiceItem and reverse stock if needed."""
        old_quantity = instance.quantity
        new_quantity = validated_data.get('quantity', old_quantity)
        item = instance.item

        # âœ… Reverse stock if item is being updated
        if item:
            item.closingStock += old_quantity  # Add back old stock
            item.save()

        # âœ… Deduct new stock if updated quantity is less
        if item and new_quantity > 0:
            if item.closingStock < new_quantity:
                raise serializers.ValidationError(f"Not enough stock for {item.itemName}. Available: {item.closingStock}")
            item.closingStock -= new_quantity
            item.save()

        # âœ… Update the InvoiceItem
        for attr, value in validated_data.items():
            setattr(instance, attr, value)
        instance.save()
        return instance
        
    
    def delete(self, instance):
        print("""Reverse stock when item is deleted.""")
        item = instance.item
        if item:
            item.closingStock += instance.quantity
            item.save()
        instance.delete()

class InvoiceSerializer(serializers.ModelSerializer):
    invoice_items = InvoiceItemSerializer(many=True, required=False)
    total_amount = serializers.DecimalField(source='get_total_amount', read_only=True, max_digits=10, decimal_places=2)
    balance_amount = serializers.DecimalField(source='get_balance_amount', read_only=True, max_digits=10, decimal_places=2)
    taxable_amount = serializers.DecimalField(source='get_taxable_amount', read_only=True, max_digits=10, decimal_places=2)
    tcs_on = serializers.ChoiceField(choices=Invoice.TCS_ON_CHOICES, required=False)
    tcs_amount = serializers.DecimalField(source='get_tcs_amount', read_only=True, max_digits=10, decimal_places=2)
    status = serializers.CharField(read_only=True)
    next_invoice_number = serializers.SerializerMethodField()
    bank_account = serializers.PrimaryKeyRelatedField(
        queryset=BankAccount.objects.all(),
        required=False,
        allow_null=True
    )

    class Meta:
        model = Invoice
        fields = [
            'business', 'id', 'invoice_no', 'date', 'party', 'status',
            'payment_term', 'due_date', 'amount_received', 'is_fully_paid',
            'payment_method', 'discount', 'total_amount', 'balance_amount',
            'invoice_items', 'notes', 'signature', 'taxable_amount',
            'apply_tcs', 'tcs', 'tcs_on', 'tcs_amount', 'next_invoice_number',
            'bank_account'
        ]
        read_only_fields = [
            'business', 'total_amount', 'balance_amount',
            'taxable_amount', 'tcs_amount', 'next_invoice_number'
        ]

    def get_next_invoice_number(self, obj):
        request = self.context.get('request')
        if request and request.user:
            business = get_current_business(request.user)
            return Invoice.get_next_invoice_number(business)
        return None

    def get_balance_amount(self, obj):
        # Ensure that both operands are of the same type (Decimal)
        total_amount = obj.get_total_amount()
        amount_received = Decimal(obj.amount_received)  # Convert amount_received to Decimal

        return total_amount - amount_received

    def validate(self, data):
        data = super().validate(data)
        
        # Validate bank account for non-cash payments
        payment_method = data.get('payment_method')
        if payment_method in BANK_PAYMENT_METHODS:
            bank_account = data.get('bank_account')
            if not bank_account:
                raise serializers.ValidationError({
                    "bank_account": "Bank account is required for non-cash payment methods"
                })
            
            # Verify bank account belongs to the business
            business = self.context['request'].user.current_business
            if bank_account.business != business:
                raise serializers.ValidationError({
                    "bank_account": "Invalid bank account"
                })
            
            # Verify it's a bank account (not cash)
            if bank_account.account_type != 'Bank':
                raise serializers.ValidationError({
                    "bank_account": "Selected account must be a bank account"
                })

        return data

    def create(self, validated_data):
        print("create")
        invoice_items_data = validated_data.pop('invoice_items', [])
            
        invoice = Invoice.objects.create(**validated_data)

        # âœ… Create each InvoiceItem without validation errors
        for item_data in invoice_items_data:
            item_data['invoice'] = invoice  # Inject invoice here after creation
            InvoiceItem.objects.create(**item_data)

        # âœ… The save() method in Invoice will automatically update balance
        invoice.save()
        return invoice

    def update(self, instance, validated_data):
        """Update Invoice and its related InvoiceItems."""
        # Extract invoice_items from validated data
        invoice_items_data = validated_data.pop('invoice_items', [])
        # Step 1: Update the main Invoice fields
        for attr, value in validated_data.items():
            setattr(instance, attr, value)
        instance.save()  # Save the main Invoice model after updating its fields
        # Step 2: Handle InvoiceItem updates/deletions
        existing_items = instance.invoice_items.all()
        existing_item_ids = [item.id for item in existing_items]
        updated_item_ids = [item_data.get('id') for item_data in invoice_items_data if item_data.get('id')]
        # Step 3: Delete removed items
        for item_id in set(existing_item_ids) - set(updated_item_ids):
            item_to_delete = instance.invoice_items.get(id=item_id)
            item_to_delete.delete()  # Delete the InvoiceItem
        # Step 4: Update or Create new items
        for item_data in invoice_items_data:
            item_id = item_data.get('id')
            if item_id:
                # Update existing item
                item_instance = existing_items.get(id=item_id)
                # Update the item using the InvoiceItemSerializer
                InvoiceItemSerializer().update(item_instance, item_data)
            else:
                # Create new item
                item_data['invoice'] = instance  # Associate the new InvoiceItem with the current Invoice
                InvoiceItem.objects.create(**item_data)
        # Step 5: Automatically recalculate balance after saving changes
        instance.save()  # This ensures the updated Invoice object reflects the changes
        return instance


class InvoiceViewSet(viewsets.ModelViewSet):
    queryset = Invoice.objects.all()
    serializer_class = InvoiceSerializer

class QuotationItemSerializer(serializers.ModelSerializer):
    item_name = serializers.CharField(source='item.itemName', read_only=True)
    service_name = serializers.CharField(source='service.serviceName', read_only=True)
    available_stock = serializers.DecimalField(source='get_available_stock', read_only=True, max_digits=10, decimal_places=2)
    price_item = serializers.DecimalField(source='get_price_item', read_only=True, max_digits=10, decimal_places=2)
    amount = serializers.DecimalField(source='get_amount', read_only=True, max_digits=10, decimal_places=2)
    tax_rate = serializers.DecimalField(source='gstTaxRate.rate', read_only=True, max_digits=5, decimal_places=2)
    tax_rate_amount = serializers.DecimalField(source='get_tax_rate_amount', read_only=True, max_digits=10, decimal_places=2)
    cess_rate = serializers.DecimalField(source='gstTaxRate.cess_rate', read_only=True, max_digits=5, decimal_places=2)
    cess_rate_amount = serializers.DecimalField(source='get_cess_rate_amount', read_only=True, max_digits=10, decimal_places=2)
    cgst = serializers.DecimalField(source='get_cgst', read_only=True, max_digits=5, decimal_places=2)
    cgst_amount = serializers.DecimalField(source='get_cgst_amount', read_only=True, max_digits=10, decimal_places=2)
    igst = serializers.DecimalField(source='gstTaxRate.rate', read_only=True, max_digits=5, decimal_places=2)
    igst_amount = serializers.DecimalField(source='get_igst_amount', read_only=True, max_digits=10, decimal_places=2)
    sgst = serializers.DecimalField(source='get_sgst', read_only=True, max_digits=5, decimal_places=2)
    sgst_amount = serializers.DecimalField(source='get_sgst_amount', read_only=True, max_digits=10, decimal_places=2)
    hsnCode = serializers.CharField(source='item.hsnCode', read_only=True)
    sacCode = serializers.CharField(source='service.sacCode', read_only=True)
    salesPrice_with_tax = serializers.DecimalField(source='get_salesPrice_without_tax', read_only=True, max_digits=5, decimal_places=2)
    purchasePrice_with_tax = serializers.DecimalField(source='get_purchasePrice_without_tax', read_only=True, max_digits=5, decimal_places=2)
    salesPrice_without_tax = serializers.DecimalField(source='get_salesPrice_with_tax', read_only=True, max_digits=5, decimal_places=2)
    purchasePrice_without_tax = serializers.DecimalField(source='get_purchasePrice_with_tax', read_only=True, max_digits=5, decimal_places=2)
    salesPriceType = serializers.CharField(source='get_price_type', read_only=True)
    type = serializers.CharField(source='get_type', read_only=True)
    
    class Meta:
        model = QuotationItem
        fields = [
            'id', 'quotation', 'item', 'item_name', 'service', 'service_name', 
            'quantity', 'unit_price', 'amount', 'price_item', 'available_stock', 'gstTaxRate', 
            'tax_rate', 'tax_rate_amount', 'cess_rate', 'cess_rate_amount' , 'cgst' , 'cgst_amount' ,'igst' , 'igst_amount' ,'sgst', 'sgst_amount', 'hsnCode' , 'sacCode',
            'salesPrice_with_tax', 'purchasePrice_with_tax', 'salesPrice_without_tax', 'purchasePrice_without_tax', 'salesPriceType','type','discount'
        ]
        extra_kwargs = {
            'quotation': {'required': False}  # ðŸ‘ˆ This is the fix
        }

    def validate(self, data):
        """Ensure either item or service is provided, not both."""
        item = data.get('item')
        service = data.get('service')

        if not item and not service:
            raise serializers.ValidationError("Either 'item' or 'service' must be provided.")
        if item and service:
            raise serializers.ValidationError("You can only select either 'item' or 'service', not both.")
        if 'quantity' in data and data['quantity'] <= 0:
            raise serializers.ValidationError("Quantity must be a positive number.")

        # Ensure stock availability for items
        if item:
            if item.closingStock < data['quantity']:
                raise serializers.ValidationError(f"Not enough stock for {item.itemName}. Available: {item.closingStock}")
        return data
    

    def create(self, validated_data):
        """Create InvoiceItem and deduct stock."""
        item = validated_data.get('item')
        invoice_item = QuotationItem.objects.create(**validated_data)

        # âœ… Deduct stock if it's an item (not service)
        if item:
            item.closingStock -= validated_data['quantity']
            item.save()

        return invoice_item
    
    def update(self, instance, validated_data):
        """Update InvoiceItem and reverse stock if needed."""
        old_quantity = instance.quantity
        new_quantity = validated_data.get('quantity', old_quantity)
        item = instance.item

        # âœ… Reverse stock if item is being updated
        if item:
            item.closingStock += old_quantity  # Add back old stock
            item.save()

        # âœ… Deduct new stock if updated quantity is less
        if item and new_quantity > 0:
            if item.closingStock < new_quantity:
                raise serializers.ValidationError(f"Not enough stock for {item.itemName}. Available: {item.closingStock}")
            item.closingStock -= new_quantity
            item.save()

        # âœ… Update the InvoiceItem
        for attr, value in validated_data.items():
            setattr(instance, attr, value)
        instance.save()
        return instance
    
    def delete(self, instance):
        print("""Reverse stock when item is deleted.""")
        item = instance.item
        if item:
            item.closingStock += instance.quantity
            item.save()
        instance.delete()

class QuotationSerializer(serializers.ModelSerializer):
    quotation_items = QuotationItemSerializer(many=True)
    total_amount = serializers.DecimalField(source='get_total_amount', read_only=True, max_digits=10, decimal_places=2)
    taxable_amount = serializers.DecimalField(source='get_taxable_amount', read_only=True, max_digits=10, decimal_places=2)
    balance_amount = serializers.DecimalField(source='get_total_amount', read_only=True, max_digits=10, decimal_places=2)
    status = serializers.CharField(read_only=True)
    next_quotation_number = serializers.SerializerMethodField()

    class Meta:
        model = Quotation
        fields = fields = [
            'business','id', 'quotation_no', 'date', 'party', 'status', 
            'payment_term', 'due_date', 'discount', 'total_amount', 'balance_amount', 'quotation_items', 'notes' , 'signature' , 'taxable_amount','next_quotation_number'
        ]
        read_only_fields = ['business','next_quotation_number']

    
    def get_next_quotation_number(self, obj):
        request = self.context.get('request')
        if request and request.user:
            business = get_current_business(request.user)
            return Quotation.get_next_quotation_number(business)
        return None

    def create(self, validated_data):
        print("create")
        invoice_items_data = validated_data.pop('quotation_items', [])   
        invoice = Quotation.objects.create(**validated_data)

        # âœ… Create each InvoiceItem without validation errors
        for item_data in invoice_items_data:
            item_data['quotation'] = invoice  # Inject invoice here after creation
            QuotationItem.objects.create(**item_data)

        # âœ… The save() method in Invoice will automatically update balance
        invoice.save()
        return invoice
 
    def update(self, instance, validated_data):
        print("Update")
        # Extract the invoice_items from validated data (if present)
        invoice_items_data = validated_data.pop('quotation_items', [])
       
        # Step 1: Update invoice fields (main Invoice object)
        for attr, value in validated_data.items():
            setattr(instance, attr, value)
        instance.save()  # Save the main Invoice model after updating its fields
        
        # Step 2: Handle InvoiceItem updates/deletions
        existing_items = instance.quotation_items.all()
        existing_item_ids = [item.id for item in existing_items]
        updated_item_ids = [item_data.get('id') for item_data in invoice_items_data if item_data.get('id')]

        # Step 3: Delete removed items
        for item_id in set(existing_item_ids) - set(updated_item_ids):
            item_to_delete = instance.quotation_items.get(id=item_id)
            QuotationItemSerializer().delete(item_to_delete)

        # Step 4: Update or Create new items
        for item_data in invoice_items_data:
            item_id = item_data.get('id')
            if item_id:
                # Update existing item
                item_instance = instance.quotation_items.get(id=item_id)
                if 'quantity' in item_data:
                    item_instance.quantity = item_data['quantity']

                QuotationItemSerializer().update(item_instance, item_data)
            else:
                # Create new item
                item_data['quotation'] = instance  # Associate the new InvoiceItem with the current Invoice
                QuotationItem.objects.create(**item_data)

        # Step 5: Automatically recalculate balance after saving changes
        instance.save()  # This ensures the updated Invoice object reflects the changes
        return instance
    
class QuotationViewSet(viewsets.ModelViewSet):
    queryset=Quotation.objects.all()
    serializer_class=QuotationSerializer
##########################################################################################################################
############################################################################################################################
####################################################################################################################################


class Purchase(models.Model):
    STATUS_CHOICES = [
        ('Unpaid', 'Unpaid'),
        ('Partially Paid', 'Partially Paid'),
        ('Paid', 'Paid')
    ]
    
    PAYMENT_METHOD_CHOICES = (
        ('Cash', "Cash"),
        ('UPI', "UPI"),
        ('Card', "Card"),
        ('Netbanking', "Netbanking"),
        ('Bank Transfer', "Bank Transfer"),
        ('Cheque', "Cheque"),
    )

    TCS_ON_CHOICES = (
        ('taxable', 'taxable'),
        ('total', 'total'),
    )

    business = models.ForeignKey(Business, on_delete=models.CASCADE, blank=True , null=True, related_name='purchase')
    purchase_no = models.IntegerField()
    date = models.DateField(auto_now_add=False)
    party = models.ForeignKey(Party, on_delete=models.CASCADE)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='Unpaid')
    payment_term = models.PositiveIntegerField(help_text="Number of days for the payment term", blank=True, null=True,default=30)
    due_date = models.DateField(blank=True, null=True)
    original_invoice_no=models.CharField(max_length=50,null=True,blank= True)
    is_fully_paid = models.BooleanField(default=False, help_text="Mark as fully paid")
    amount_received = models.DecimalField(max_digits=10, decimal_places=2, default=0.0, help_text="Amount received")
    balance_amount = models.DecimalField(max_digits=10, decimal_places=2, default=0.0, help_text="Balance Amount")
    taxable_amount = models.DecimalField(max_digits=10, decimal_places=2, default=0.0, help_text="Taxable Amount")
    total_amount = models.DecimalField(max_digits=10, decimal_places=2, default=0.0, help_text="Total Amount")
    total_payable_amount = models.DecimalField(max_digits=10, decimal_places=2, default=0.0, help_text="Total Payable Amount")
    bank_account = models.ForeignKey('cash_and_bank.BankAccount', on_delete=models.SET_NULL, null=True, blank=True, related_name='purchase')
    

    apply_tcs = models.BooleanField(default=False)
    tcs = models.ForeignKey('sales.Tcs' ,on_delete=models.SET_NULL, blank=True , null=True, related_name='purchase_tcs')
    tcs_on = models.CharField(max_length=20, choices=TCS_ON_CHOICES,default='total',help_text="Apply TCS on either taxable or total amount")
    tcs_amount = models.DecimalField(max_digits=10, decimal_places=2, default=0.0, help_text="TCS Amount")

    apply_tds = models.BooleanField(default=False)
    tds = models.ForeignKey('sales.Tds', on_delete=models.SET_NULL, blank=True, null=True, related_name='purchase_tds')
    tds_amount = models.DecimalField(max_digits=10, decimal_places=2, default=0.0)

    payment_method = models.CharField(max_length=20, choices=PAYMENT_METHOD_CHOICES,  default='Cash', blank=True, null=True)
    discount = models.DecimalField(max_digits=5, decimal_places=2, default=0,blank=True , null=True, help_text="Discount in percentage.")
    notes = models.TextField(blank=True,null=True)
    signature = models.ImageField(upload_to='static/images/', null=True, blank=True)
    
    def save(self, *args, **kwargs):
        # Automatically calculate due_date
        if self.date and self.payment_term:
            self.due_date = self.date + timedelta(days=self.payment_term)

        # Save the invoice first to get the primary key (for editing)
        is_new = not self.pk

        if is_new:
            # For new invoice, do the first save
            print("new save --")
            super().save(*args, **kwargs)

        self.balance_amount = self.get_balance_amount()
        self.taxable_amount = self.get_taxable_amount()
        self.total_amount = self.get_total_amount()
        self.total_payable_amount = self.get_total_payable_amount()
        self.tcs_amount = self.get_tcs_amount()
        self.tds_amount = self.get_tds_amount()
 
        # Now that it has a primary key, you can safely calculate total amount
        if not is_new:
            print("old invoice -- 1")
            self.reverse_previous_balance_impact()

        # Now that the invoice has been saved, proceed with the balance update
        if self.is_fully_paid:
            self.handle_fully_paid()
        elif self.amount_received > 0:
            self.handle_partially_paid()
        else:
            self.handle_unpaid()

        # Update the status of the invoice (Paid/Unpaid/Partially Paid)
        self.update_status()

        # Save the updated fields (no double save)
        super().save(update_fields=['party','purchase_no', 'status', 'amount_received','total_amount','balance_amount' ,'is_fully_paid', 'due_date', 'notes', 'discount', 'payment_method', 'payment_term', 'tcs_amount','tds_amount','taxable_amount','business' ,'total_payable_amount','tcs','apply_tcs','tds','apply_tds','bank_account'])

    
    def handle_fully_paid(self):
        # âœ… Scenario 1 & Scenario 4: Fully Paid (at creation or after edit)
        # No balance changes to the party
        self.status = 'Paid'
        if self.apply_tds and self.tds and self.business and self.business.tds:
            self.amount_received = self.get_total_payable_amount()
        else:
            self.amount_received = self.get_total_amount()
        print("paid success")


    def handle_partially_paid(self):
        # âœ… Scenario 3 & Scenario 5: Partially Paid
        if self.apply_tds and self.tds and self.business and self.business.tds:
           total_amount = self.get_total_payable_amount()
        else:
            total_amount = self.get_total_amount()
        print(f"Total Amount: {total_amount}") 
        remaining_amount = total_amount - self.amount_received
        print(remaining_amount , total_amount , self.amount_received)

        # Step 1: Deduct from To Pay
        if self.party.balance_type == 'To Collect' and self.party.closing_balance > 0:
            if remaining_amount >= self.party.closing_balance:
                remaining_amount -= self.party.closing_balance
                self.party.closing_balance = 0
                self.party.balance_type = 'To Pay'
            else:
                self.party.closing_balance -= remaining_amount
                remaining_amount = 0

        # Step 2: Add remaining amount (if any) to To Collect
        if remaining_amount > 0:
            if self.party.balance_type == 'To Collect' and self.party.closing_balance == 0:
                self.party.balance_type = 'To Pay'
            self.party.closing_balance += remaining_amount

        self.party.save()
        self.status = 'Partially Paid'
        print("Partially paid success")


    def handle_unpaid(self):
        print("\n--- HANDLE UNPAID ---")
        print(f"Party: {self.party.party_name}")
        print(f"Balance Type (Before): {self.party.balance_type}")
        print(f"Closing Balance (Before): {self.party.closing_balance}")
            # âœ… Scenario 2 & Scenario 6: Unpaid
        if self.apply_tds and self.tds and self.business and self.business.tds:
           total_amount = self.get_total_payable_amount()
        else:
            total_amount = self.get_total_amount()
        print(f"Total Amount: {total_amount}")  # Debugging line
        print(f"Total Payable: {self.get_total_payable_amount()} | Total: {self.get_total_amount()}")
        remaining_amount = total_amount

        # Step 1: Deduct from To Pay
        if self.party.balance_type == 'To Collect' and self.party.closing_balance > 0:
            if remaining_amount >= self.party.closing_balance:
                remaining_amount -= self.party.closing_balance
                self.party.closing_balance = 0
                self.party.balance_type = 'To Pay'
            else:
                self.party.closing_balance -= remaining_amount
                remaining_amount = 0

        # Step 2: Add remaining amount (if any) to To Collect
        if remaining_amount > 0:
            if self.party.balance_type == 'To Collect' and self.party.closing_balance == 0:
                self.party.balance_type = 'To Pay'
            self.party.closing_balance += remaining_amount

        self.party.save()
        self.status = 'Unpaid'
        print("Unpaid success")
        print(f"Balance Type (After): {self.party.balance_type}")
        print(f"Closing Balance (After): {self.party.closing_balance}")
        print("--- END HANDLE UNPAID ---\n")

    def reverse_previous_balance_impact(self):
        print("\n--- REVERSING BALANCE IMPACT ---")
        # âœ… Reverse any previous balance impact based on the old status
        try:
            old_invoice = Purchase.objects.get(pk=self.pk)
            print(f"Old Invoice Found: ID {old_invoice.id}")
        except Purchase.DoesNotExist:
            # Handle the case where the old invoice doesn't exist (shouldn't happen in a valid state)
            print("Old invoice does not exist.")
            return
        # Case 1: Fully Paid - No impact to reverse
        print(f"Old Invoice Status: {old_invoice.status}")
        print(f"Old Apply TDS: {old_invoice.apply_tds} | TDS: {old_invoice.tds}")
        if old_invoice.status == 'Paid':
            print("âœ… No reversal needed (status = Paid)")
            return

        # Case 2: Unpaid or Partially Paid
        if old_invoice.status in ['Unpaid', 'Partially Paid']:
            if old_invoice.apply_tds and old_invoice.tds and old_invoice.business and old_invoice.business.tds:
                total_amount = old_invoice.total_payable_amount
                print(f"Using total_payable_amount: {total_amount}")
            else:
                total_amount = old_invoice.total_amount
                print(f"Using total_amount: {total_amount}")
            received_amount = old_invoice.amount_received  # Should be set correctly during the save
            balance_amount = total_amount - received_amount  # Should be set correctly during the save

            print(f"ðŸ’° Reversal Amounts")
            print(f"   - Total: {total_amount}")
            print(f"   - Received: {received_amount}")
            print(f"   - Balance: {balance_amount}")

            # Log party balance before
            print(f"Party before reversal: {old_invoice.party.party_name}")
            print(f"   - Balance Type: {old_invoice.party.balance_type}")
            print(f"   - Closing Balance: {old_invoice.party.closing_balance}")

            # Reverse impact based on the old balance type
            if old_invoice.status == 'Unpaid':
                print("Reversing Unpaid Balance")
                self.reverse_unpaid_balance(total_amount)
            elif old_invoice.status == 'Partially Paid':
                print("Reversing Partially Paid Balance")
                self.reverse_partially_paid_balance(balance_amount)
            
        old_party = old_invoice.party
        if old_party != self.party:
            print("Party changed. Reversing old party balance impact.")
            self.transfer_balance_to_new_party(old_party,balance_amount)
            print("--- END REVERSAL ---\n")

    def reverse_unpaid_balance(self, total_amount):
        # âœ… Reverse the unpaid logic impact
        if self.party.balance_type == 'To Pay':
            self.party.closing_balance -= total_amount
            if self.party.closing_balance < 0:
                self.party.balance_type = 'To Collect'
                self.party.closing_balance = abs(self.party.closing_balance)
        elif self.party.balance_type == 'To Collect':
            self.party.closing_balance += total_amount
        self.party.save()

    def reverse_partially_paid_balance(self, received_amount):
        # Reverse the partially paid logic impact based on previous payments
        print("Reversing partially paid balance")
        print(f"Received amount to reverse: {received_amount}")
        print(f"Current party balance: {self.party.closing_balance} ({self.party.balance_type})")
        if self.party.balance_type == 'To Pay':
            self.party.closing_balance -= received_amount
            if self.party.closing_balance < 0:
                self.party.balance_type = 'To Collect'
                self.party.closing_balance = abs(self.party.closing_balance)
        elif self.party.balance_type == 'To Collect':
            self.party.closing_balance += received_amount
            print(f"[DEBUG] Party balance after reversal: {self.party.closing_balance} ({self.party.balance_type})")
        self.party.save()


    def update_status(self):
        total_amount = self.get_total_amount()
        if self.is_fully_paid or self.amount_received >= total_amount:
            self.status = 'Paid'
        elif self.amount_received > 0:
            self.status = 'Partially Paid'
        else:
            self.status = 'Unpaid'
        print(self.status)

    def get_tcs_amount(self):
        if self.apply_tcs and self.tcs and self.business and self.business.tcs:
            rate = self.tcs.rate or Decimal('0.00')

            if self.tcs_on == 'total':
                base_amount = self.get_total_amount(without_tcs=True)
            else:
                base_amount = self.get_taxable_amount()

            return (base_amount * rate / Decimal('100.00')).quantize(Decimal("0.00"), rounding=ROUND_HALF_UP)

        return Decimal("0.00")
    
    def get_tds_amount(self):
        if self.apply_tds and self.tds and self.business and self.business.tds:
            rate = self.tds.rate or Decimal('0.00')
            base = self.get_taxable_amount()
            return (base * rate / Decimal('100.00')).quantize(Decimal("0.00"), rounding=ROUND_HALF_UP)
        return Decimal("0.00")

    def get_total_amount(self, without_tcs=False):
        total_amount = sum(Decimal(str(item.get_amount())) for item in self.purchase_items.all())

        discount = Decimal(self.discount or 0)
        if discount > 0:
            total_amount -= (total_amount * (discount / Decimal("100")))

        # Ensure total_amount is Decimal before quantizing
        total_amount = Decimal(total_amount)

        if not without_tcs and self.apply_tcs and self.tcs and self.business and self.business.tcs:
            rate = Decimal(str(self.tcs.rate or 0))
            tcs_base = self.get_taxable_amount() if self.tcs_on == 'taxable' else total_amount
            self.tcs_amount = (tcs_base * rate / Decimal("100")).quantize(Decimal("0.00"), rounding=ROUND_HALF_UP)
            total_amount += self.tcs_amount
        else:
            self.tcs_amount = Decimal("0.00")

        return total_amount.quantize(Decimal("0.00"), rounding=ROUND_HALF_UP)
    
    def get_total_payable_amount(self, without_tcs=False):
        total_amount = sum(Decimal(str(item.get_amount())) for item in self.purchase_items.all())

        discount = Decimal(self.discount or 0)
        if discount > 0:
            total_amount -= (total_amount * (discount / Decimal("100")))

        # Ensure total_amount is Decimal before quantizing
        total_amount = Decimal(total_amount)

        if not without_tcs and self.apply_tcs and self.tcs and self.business and self.business.tcs:
            rate = Decimal(str(self.tcs.rate or 0))
            tcs_base = self.get_taxable_amount() if self.tcs_on == 'taxable' else total_amount
            self.tcs_amount = (tcs_base * rate / Decimal("100")).quantize(Decimal("0.00"), rounding=ROUND_HALF_UP)
            total_amount += self.tcs_amount
        else:
            self.tcs_amount = Decimal("0.00")

        if self.apply_tds and self.tds and self.business and self.business.tds:
            rate = Decimal(str(self.tds.rate or 0))
            tds_base = self.get_taxable_amount()
            self.tds_amount = (tds_base * rate / Decimal("100")).quantize(Decimal("0.00"), rounding=ROUND_HALF_UP)
            total_amount -= self.tds_amount
        else:
            self.tds_amount = Decimal("0.00")

        return total_amount.quantize(Decimal("0.00"), rounding=ROUND_HALF_UP)


    def get_taxable_amount(self):
        # Convert each price item to Decimal before summing
        total_amount = sum(Decimal(item.get_price_item()) for item in self.purchase_items.all())
        
        # Use 0 if discount is None
        discount = self.discount if self.discount is not None else 0
        
        if discount >= 0:
            discount_amount = total_amount * Decimal(discount / 100)  # Discount is a percentage
            total_amount -= discount_amount  # Subtract discount from total amount
        
        return total_amount

    
    def get_balance_amount(self):
        if self.apply_tds:
            total_amount = self.get_total_payable_amount()
        else:
            total_amount = self.get_total_amount()
        amount_received = Decimal(self.amount_received or 0)
        return total_amount - amount_received

    def transfer_balance_to_new_party(self, old_party,balance_amount):
        # total_amount = self.get_total_amount()  # Get total amount from the invoice
        new_party = self.party  # The new party to receive the amount
        print(f"Old Party Balance before: {old_party.closing_balance}")
        print(f"New Party Balance before: {new_party.closing_balance}")

        # # Step 1: Deduct the balance from the old party (only once)
        if old_party.balance_type == 'To Pay':
            old_party.closing_balance -= balance_amount
            if old_party.closing_balance < 0:
                old_party.balance_type = 'To Collect'
                old_party.closing_balance = abs(old_party.closing_balance)
        elif old_party.balance_type == 'To Collect':
            old_party.closing_balance += balance_amount
        
        # # Step 2: Add the balance from the old party (only once)
        if new_party.balance_type == 'To Pay':
            new_party.closing_balance += balance_amount
            if new_party.closing_balance < 0:
                new_party.balance_type = 'To Collect'
                new_party.closing_balance = abs(new_party.closing_balance)
        elif new_party.balance_type == 'To Collect':
            new_party.closing_balance -= balance_amount


        old_party.save()  # Save the old party after the deduction
        print(f"Old party balance reduced by: {balance_amount}")

        # # Save the new party once to avoid duplication
        new_party.save()  # Save the new party after the correct balance update
        # print(f"New party balance updated with: {remaining_amount}")

        print(f"Old Party Balance after: {old_party.closing_balance}")
        print(f"New Party Balance after: {new_party.closing_balance}")

    def delete(self, *args, **kwargs):
        # Handle necessary clean up before deleting the invoice or invoice item
        self.reverse_previous_balance_impact()  # Example: Reverse balance impact for the party
        for item in self.purchase_items.all():
            item.delete()
        super().delete(*args, **kwargs)

    def make_payment(self, total_payment_amount):
        """
        Method to handle payment logic without calling the full save method.
        It will update the `amount_received`, `balance_amount`, and status based on the payment.
        This method now returns the total payment amount used by this invoice.
        """
        self.balance_amount = self.get_balance_amount()  # Update balance amount

        # If the invoice balance is greater than the payment amount
        if self.balance_amount >= total_payment_amount:
            self.amount_received += total_payment_amount
            total_payment_amount = 0  # All the payment has been consumed
        else:
            # If the invoice balance is less than the payment amount, deduct the entire balance
            total_payment_amount -= self.balance_amount
            self.amount_received += self.balance_amount
            self.balance_amount = 0  # Invoice is fully paid

        self.is_fully_paid = self.balance_amount == 0  # Mark as fully paid if balance is zero
        self.update_status()  # Update the status (Paid/Partially Paid/Unpaid)

        # Save the updated invoice
        self.save(update_fields=['amount_received', 'balance_amount', 'is_fully_paid', 'status'])

        return total_payment_amount  # Return the remaining amount that can be used for other invoices
    
    class Meta:
        unique_together = ('business', 'purchase_no')  # or UniqueConstraint
        ordering = ['purchase_no']

    def __str__(self):
        return f"Purchase {self.purchase_no} - {self.party}"
    
    @classmethod
    def get_next_purchase_number(cls, business):
        """Generate the next invoice number for a business."""
        # Get the latest invoice for this specific business
        latest_purchase = cls.objects.filter(business=business).order_by('-id').first()
        
        if latest_purchase:
            # Extract the number part and increment
            last_number = int(latest_purchase.purchase_no)
            next_purchase_no = last_number + 1
        else:
            # First invoice for this business
            next_purchase_no = 1
            
        return next_purchase_no
        
class PurchaseItem(models.Model):
    purchase = models.ForeignKey(Purchase, related_name='purchase_items', on_delete=models.CASCADE)
    item = models.ForeignKey(Item, null=True, blank=True, on_delete=models.CASCADE)  
    service = models.ForeignKey(Service, null=True, blank=True, on_delete=models.CASCADE)  # For services
    quantity = models.DecimalField(max_digits=10, decimal_places=2)
    unit_price = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)  # Unit price for both products and services
    amount = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)  # Total amount for the item or service
    discount = models.DecimalField(max_digits=5, decimal_places=2, default=0, help_text="Discount in percentage.")
    price_item = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)  # Price of item/service before tax
    gstTaxRate = models.ForeignKey(GSTTaxRate, on_delete=models.SET_NULL, null=True)
    stock_updated = models.BooleanField(default=False)  # Flag to track if stock has been updated
    
    def clean(self):
        """Ensure either item or service is selected, not both."""
        if not self.item and not self.service:
            raise ValidationError("Either 'item' or 'service' must be provided.")
        if self.item and self.service:
            raise ValidationError("You can only select either 'item' or 'service', not both.")
    
    def get_tax_rate_amount(self):
        """Calculate GST tax amount."""
        if self.gstTaxRate:
            tax_rate = self.gstTaxRate.rate / 100 if self.gstTaxRate else 0
            return (Decimal(self.get_price_item()) * tax_rate)
        return Decimal(0)

    def get_cess_rate_amount(self):
        """Calculate cess amount."""
        if self.gstTaxRate:
            cess_rate = self.gstTaxRate.cess_rate / 100 if self.gstTaxRate else 0
            return (Decimal(self.get_price_item()) * cess_rate)
        return Decimal(0)
    
    def get_cgst_amount(self):
        """Calculate GST tax amount."""
        if self.gstTaxRate:
            tax_rate = self.gstTaxRate.rate / 200 if self.gstTaxRate else 0
            return (Decimal(self.get_price_item()) * tax_rate)
        return Decimal(0)

    def get_sgst_amount(self):
        """Calculate cess amount."""
        if self.gstTaxRate:
            tax_rate = self.gstTaxRate.rate / 200 if self.gstTaxRate else 0
            return (Decimal(self.get_price_item()) * tax_rate)
        return Decimal(0)
    
    def get_igst_amount(self):
        """Calculate IGST tax amount."""
        if self.gstTaxRate:
            igst_rate = self.gstTaxRate.rate / 100 if self.gstTaxRate else 0  # IGST uses full rate
            return (Decimal(self.get_price_item()) * igst_rate)
        return Decimal(0)
    
    
    def get_cgst(self):
        if self.gstTaxRate:
            return (self.gstTaxRate.rate/2)
        return Decimal(0)
    
    def get_sgst(self):
        if self.gstTaxRate:
            return (self.gstTaxRate.rate/2)
        return Decimal(0)
    
    def get_salesPrice_with_tax(self):
        """Returns the tax-inclusive sales price if stored without tax."""
        if self.item:
            if self.item.salesPriceType == "With Tax":
                price_with_tax = self.calculate_price(self.item.salesPrice, "With Tax")
                return (price_with_tax)
            return (self.item.salesPrice)  # Already tax-exclusive
        elif self.service:
            if self.service.salesPriceType == "With Tax":
                price_with_tax = self.calculate_price(self.service.salesPrice, "With Tax")
                return (price_with_tax)
            return (self.service.salesPrice)  # Service price * quantity
        return 0.0
    
    def get_salesPrice_without_tax(self):
        """Returns the tax-inclusive sales price if stored without tax."""
        if self.item:
            if self.item.salesPriceType == "Without Tax":
                price_without_tax = self.calculate_price(self.item.salesPrice, "Without Tax")
                return (price_without_tax)
            return (self.item.salesPrice)  # Already tax-exclusive
        elif self.service:
            if self.service.salesPriceType == "Without Tax":
                price_without_tax = self.calculate_price(self.service.salesPrice, "Without Tax")
                return (price_without_tax)
            return (self.service.salesPrice)  # Service price * quantity
        return 0.0
    
    def get_purchasePrice_with_tax(self):
        """Returns the tax-inclusive sales price if stored without tax."""
        if self.item:
            if self.item.purchasePriceType == "With Tax":
                price_without_tax = self.calculate_price(self.item.purchasePrice, "With Tax")
                return (price_without_tax)
            return (self.item.purchasePrice)  # Already tax-exclusive
        return 0.0
    
    def get_purchasePrice_without_tax(self):
        """Returns the tax-inclusive sales price if stored without tax."""
        if self.item:
            if self.item.purchasePriceType == "Without Tax":
                price_without_tax = self.calculate_price(self.item.purchasePrice, "Without Tax")
                return (price_without_tax)
            return (self.item.purchasePrice)  # Already tax-exclusive
        return 0.0
    
    def get_price_type(self):
        if self.item:
            if self.item.purchasePriceType == "With Tax":
                return (self.item.purchasePriceType)
            return (self.item.purchasePriceType)  # Already tax-exclusive
        elif self.service:
             if self.service.salesPriceType == "With Tax":
                return 0  # Service price * quantity
    
    def get_type(self):
        if self.item:
            if self.item.itemType == "Product":
                return 'item'
        elif self.service:
            if self.service.serviceType == "Service":
                return 'service'
    
    def calculate_price(self, price, price_type):
        """Calculates tax-inclusive or tax-exclusive price based on GST and Cess rate."""
        tax_rate = self.gstTaxRate.rate / 100 if self.gstTaxRate else 0
        cess_rate = self.gstTaxRate.cess_rate / 100 if self.gstTaxRate else 0
        
        # Combined GST + Cess rate
        total_rate = tax_rate + cess_rate
        
        if price_type == "With Tax":
            # Extract base price from tax-inclusive price
            return (price / (1 + total_rate)) if total_rate > 0 else price
        else:
            # Add GST + Cess to the base price
            return (price * (1 + total_rate))
        
        
    def get_amount(self):
        """Calculates the total amount for the item or service, applying discounts if any."""
        if self.item:
            if self.item.purchasePriceType == "Without Tax":
                price_with_tax = self.calculate_price(self.item.purchasePrice, "Without Tax")
                total_amount = round(price_with_tax * self.quantity, 2)
            else:
                total_amount = round(self.item.purchasePrice * self.quantity, 2)  # Already tax-inclusive
             # Apply the discount to the total amount (if any)
            if self.discount > 0:
                discount_amount = total_amount * (self.discount / 100)  # Discount is a percentage
                total_amount -= discount_amount  # Subtract discount from total amount
            return round(total_amount, 2)
        
        elif self.service:

            return 0.0       
        return 0.0  # If no item or service, return 0

    def get_price_item(self):
        """Returns the price of the item or service (excluding tax), applying discounts if any."""
        total_price = 0.0
        
        if self.item:
            # Handle item price calculation based on sales type
            if self.item.purchasePriceType == "With Tax":
                price_without_tax = self.calculate_price(self.item.purchasePrice, "With Tax")
                total_price = price_without_tax * self.quantity
            else:
                total_price = self.item.purchasePrice * self.quantity  # Already tax-exclusive
            
            # Apply discount if any
            if hasattr(self, 'discount') and self.discount > 0:
                discount_amount = total_price * (self.discount / 100)
                total_price -= discount_amount
        
        elif self.service:
        
            return 0.0
        # Return the final price, rounded to two decimal places
        return round(total_price, 2)


    def get_available_stock(self):
        """Returns the remaining stock for products. For services, stock is not managed."""
        if self.item:
            return self.item.closingStock
        return None  # Services don't have stock management

    def save(self, *args, **kwargs):
        """Override save method to calculate amount and unit price for both items and services."""
        self.full_clean()  # Ensure validation
        if self.item:
            self.unit_price = self.item.purchasePrice  # For products
            self.price_item = self.item.purchasePrice  # Price of item before tax
            # Check if sufficient stock is available and update
        elif self.service:
            self.unit_price = 0  # For services
            self.price_item = 0  # Service price before tax
        
        self.amount = self.get_amount()  # Calculate the total amount (based on item or service)

        super().save(*args, **kwargs)

    def delete(self, *args, **kwargs):
        # Handle necessary clean up before deleting the invoice or invoice item
        print("""Reverse stock when item is deleted 1.""")
        item = self.item
        if item:
            item.closingStock -= self.quantity
            item.save()
        super().delete(*args, **kwargs)

    def __str__(self):
        if self.item:
            return f"{self.item.itemName} ({self.quantity} * {self.unit_price})"
        elif self.service:
            return f"{self.service.serviceName} ({self.quantity} * {self.unit_price})"
        return "Unknown Item or Service"









# serializers.py
from rest_framework import serializers
from .models import DocumentTracking

class DocumentTrackingSerializer(serializers.ModelSerializer):
    document_number = serializers.SerializerMethodField()

    class Meta:
        model = DocumentTracking
        fields = [
            'id', 'business', 'document_type', 'invoice', 'creditnote', 'purchase', 'debitnote',
            'is_sent', 'is_opened', 'sent_at', 'opened_at', 'created_at', 'document_number'
        ]
        read_only_fields = ['created_at', 'document_number']

    def get_document_number(self, obj):
        return obj.document_number()


# utils.py
from django.utils.dateparse import parse_datetime
from .models import DocumentTracking
from invoice.models import Invoice
from creditnote.models import CreditNote
from purchase.models import Purchase
from debitnote.models import DebitNote

DOCUMENT_MODELS = {
    'Invoice': Invoice,
    'CreditNote': CreditNote,
    'Purchase': Purchase,
    'DebitNote': DebitNote,
}

def update_tracking_from_log(log_path):
    with open(log_path, 'r') as f:
        for line in f:
            try:
                parts = line.strip().split('|')
                sent_at = parse_datetime(parts[0].strip())
                doc_no = parts[2].strip()
                for doc_type, model in DOCUMENT_MODELS.items():
                    field = {
                        'Invoice': 'invoice_no',
                        'CreditNote': 'credit_note_no',
                        'Purchase': 'purchase_no',
                        'DebitNote': 'debit_note_no',
                    }[doc_type]

                    doc = model.objects.filter(**{field: doc_no}).first()
                    if doc:
                        DocumentTracking.objects.update_or_create(
                            defaults={
                                'document_type': doc_type,
                                'is_sent': True,
                                'sent_at': sent_at
                            },
                            **{doc_type.lower(): doc, 'business': doc.business}
                        )
                        break
            except Exception as e:
                print(f"Error processing line: {line}\n{e}")


# views.py
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from .models import DocumentTracking
from .serializers import DocumentTrackingSerializer

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def tracking_list_view(request):
    business = request.user.profile.business  # Adjust as per your get_current_business
    queryset = DocumentTracking.objects.filter(business=business).order_by('-created_at')
    serializer = DocumentTrackingSerializer(queryset, many=True)
    return Response(serializer.data)


# urls.py
from django.urls import path
from .views import tracking_list_view

urlpatterns = [
    path('document-tracking/', tracking_list_view, name='document-tracking-list'),
]
